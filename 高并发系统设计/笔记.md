##### 01 | 高并发系统：它的通用设计方法是什么？ 

- Scale-out  横向扩展
- 异步处理
- 使用缓存

##### 02 | 架构分层

软件设计原则都在分层架构中有所体现：

**单一职责原则**规定每个类只有单一的功能，在这里可以引申为每一层拥有单一职责，且层与层之间边界清晰。

**迪米特法则**原意是一个对象应当对其它对象有尽可能少的了解，在分层架构的体现是数据的交互不能跨层，只能在相邻层之间进行。

**开闭原则**要求软件对扩展开放，对修改关闭。它的含义其实就是将抽象层和实现层分离，抽象层是对实现层共有特征的归纳总结，不可以修改，但是具体的实现是可以无限扩展，随意替换的。

##### 09 | 数据库优化方案（二）：写入数据量增加时，如何实现分库分表？

读写分离后，主从的延迟是一个关键的监控指标，可能会造成写入数据之后立刻读的时候读取不到的情况；

业界有很多的方案可以屏蔽主从分离之后数据库访问的细节，让开发人员像是访问单一数据库一样，包括有像 TDDL、Sharding-JDBC 这样的嵌入应用内部的方案，也有像 Mycat 这样的独立部署的代理方案。

##### 09 | 数据库优化方案（二）：写入数据量增加时，如何实现分库分表？ 

如果在性能上没有瓶颈点那么就尽量不做分库分表；

如果要做，就尽量一次到位，比如说 16 库 64 表就基本能够满足为了几年内你的业务的需求。

水平拆分的两种方法：
1.根据某个字段的hash值拆分
比如想把用户表拆成16库64表，方案如下
先对id进行hash操作hash(id)，这样有助于打散数据
然后对16取余 hash(id)%16，这样就得到了分库后的索引
最后对64取余 hash(id)%16%64，这样就得到了分表后的索引值

2.根据某个字段的区间或范围拆分
可以根据时间拆分

引入分库分表确实有很多优点，但也会引入新的问题
1.引入了分区分表键，也叫分区键
因为我们需要对分区键进行hash进行索引，这样就导致我们查询都要带上该分区键，比较好的解决办法是用id做分区键，但是如果有根据用户昵称查询的需求怎么办呢？
解决办法就是建立一个昵称和id的映射表
2.一些数据库的特性的实现变得困难
(1)夸库join不可用
解决办法是在业务代码中做处理
(2)求count
采取第三方组件例如redis实现

##### 10 | 发号器：如何保证分库分表后ID的全局唯一性？ 

Snowflake 的算法并不复杂，你在使用的时候可以不考虑独立部署的问题，先想清楚按照自身的业务场景，需要如何设计 Snowflake 算法中的每一部分占的二进制位数。比如你的业务会部署几个 IDC，应用服务器要部署多少台机器，每秒钟发号个数的要求是多少等等，然后在业务代码中实现一个简单的版本先使用，等到应用服务器数量达到一定规模，再考虑独立部署的问题就可以了。这样可以避免多维护一套发号器服务，减少了运维上的复杂度。

##### 13 | 缓存的使用姿势（一）：如何选择缓存的读写策略？ 

##### Cache Aside（旁路缓存）策略

它可以分为读策略和写策略，**其中读策略的步骤是：**

- 从缓存中读取数据；
- 如果缓存命中，则直接返回数据；
- 如果缓存不命中，则从数据库中查询数据；
- 查询到数据后，将数据写入到缓存中，并且返回给用户。

**写策略的步骤是：**

- 更新数据库中的记录；
- 删除缓存记录。

注意：不能先删缓存，再更新数据库，会造成数据不一致

Read/Write Through 和 Write Back 策略需要缓存组件的支持，所以比较适合你在实现本地缓存组件的时候使用；