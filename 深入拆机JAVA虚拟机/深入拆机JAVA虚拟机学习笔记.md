#### 03| Java 虚拟机将字节流转化为 Java 类的过程

这个过程可分为加载、链接以及初始化三大步骤。

加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。

链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。

初始化，则是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。

VM 参数 -verbose:class 来打印类加载的先后顺序

#### JVM 的静态绑定和动态绑定

 静态绑定
在解析时JVM便知道该调用那个目标方法

动态绑定
在运行时JVM需要根据对应的类类型来具体定位应该调用那个目标方法。对于方法重写，对应的类会拥有一个方法表（一个二维数组表，给方法标上序号，重写的方法序号一致）  

#### Java 字节码中与调用相关的指令共有五种。

1. invokestatic：用于调用静态方法。
2. invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
3. invokevirtual：用于调用非私有实例方法。
4. invokeinterface：用于调用接口方法。
5. invokedynamic：用于调用动态方法。

#### 虚方法调用

Java 里所有非私有实例方法调用都会被编译成 invokevirtual 指令，而接口方法调用都会被编译成 invokeinterface 指令。这两种指令，均属于 Java 虚拟机中的虚方法调用。

##### 内联缓存

1. 单态（monomorphic）指的是仅有一种状态的情况。
2. 多态（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。
3. 超多态（megamorphic）指的是更多种状态的情况。通常我们用一个具体数值来区分多态和超多态。在这个数值之下，我们称之为多态。否则，我们称之为超多态

##### finally是怎么实现无论异常与否都能被执行的？

​	这个事情是由编译器来实现的，现在的做法是这样的，编译器在编译Java代码时，会复制finally代码块的内容，然后分别放在try-catch代码块所有的正常执行路径及异常执行路径的出口中。



#### javap：查阅 Java 字节码

方法内联指的是编译器在编译一个方法时，将某个方法调用的目标方法也纳入编译范围内，并用其返回值替代原方法调用这么个过程。

```
// 获取方法句柄的不同方式
MethodHandles.Lookup l = Foo.lookup(); // 具备 Foo 类的访问权限
Method m = Foo.class.getDeclaredMethod("bar", Object.class);
MethodHandle mh0 = l.unreflect(m);
 
MethodType t = MethodType.methodType(void.class, Object.class);
MethodHandle mh1 = l.findStatic(Foo.class, "bar", t);
```

#### 10 | java对象的内存布局

 对象头

每个对象都有一个对象头，对象头包括两部分，标记信息和类型指针。

标记信息包括哈希值，锁信息，GC信息。类型指针指向这个对象的class。

两个信息分别占用8个字节，所以每个对象的额外内存为16个字节。很消耗内存。  

压缩指针

内存对齐

#### 11 |垃圾回收

可达性分析算法

​	这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。

GC Roots 包括（但不限于）如下几种：

1. Java 方法栈桢中的局部变量；
2. 已加载类的静态变量；
3. JNI handles；
4. 已启动且未停止的 Java 线程。

Stop-the-world 以及安全点

##### 垃圾回收的三种方式

第一种是清除（sweep）

第二种是压缩（compact）

第三种则是复制（copy）

Java 虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。

#### 13 | 内存模型

内存可见性规则。

#### 14 | Java虚拟机是怎么实现synchronized的？

monitorenter 和 monitorexit 指令。这两种指令均会消耗操作数栈上的一个引用类型的元素（也就是 synchronized 关键字括号里的引用），作为所要加锁解锁的锁对象。

对象头中的标记字段（mark word）。它的最后两位便被用来表示该对象的锁状态。其中，00 代表轻量级锁，01 代表无锁（或偏向锁），10 代表重量级锁，11 则跟垃圾回收算法的标记有关。

重量级锁

轻量级锁

 java 虚拟机会尝试用CAS（compare-and-swap）操作替换锁对象的标记字段

偏向锁

#### 15 | Java语法糖与Java编译器

Java语法糖有那几种呢？如下所示：
包装类型和基本类型间的转换，自动装箱和拆箱的设计
泛型的设计
变长参数的设计
try-with-resources，关闭资源的设计
在同一个catch代码块中捕获多种异常
finally代码块总是被执行的设计
foreach循环数组的设计
foreach循环Iterable对象的设计

#### 16 | 即时编译

​		从 Java 8 开始，Java 虚拟机默认采用分层编译的方式。它将执行分为五个层次，分为为 0 层解释执行，1 层执行没有 profiling 的 C1 代码，2 层执行部分 profiling 的 C1 代码，3 层执行全部 profiling 的 C1 代码，和 4 层执行 C2 代码。

中间表达形式（IR）

​		在编译原理课程中，我们通常将编译器分为前端和后端。其中，前端会对所输入的程序进行词法分析、语法分析、语义分析，然后生成中间表达形式，也就是 IR（Intermediate Representation ）。后端会对 IR 进行优化，然后生成目标代码。

#### 19 | Java字节码（基础篇）

操作数栈

Java 字节码是 Java 虚拟机所使用的指令集。

#### 20 | 方法内联

#### 22 | HotSpot虚拟机的intrinsic

HotSpot 虚拟机将对标注了`@HotSpotIntrinsicCandidate`注解的方法的调用，替换为直接使用基于特定 CPU 指令的高效实现。这些方法我们便称之为 intrinsic。

用到Intrinsic的地方：

java.util.concurrent，

`StringBuilder`和`StringBuffer`类

`String`类、`StringLatin1`类、`StringUTF16`类和`Arrays`类的方法

#### 23 | 逃逸分析

逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”

编译器判断对象逃逸的依据有两个：一是看对象是否被存入堆中，二是看对象是否作为方法调用的调用者或者参数。

即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。

#### 25 | 循环优化

1：循环无关码外提——将循环内的某些无关代码外移，减少某些程序的反复执行
2：循环展开——减少循环条件的判断，针对循环次数少的循环
3：循环判断外提——减少每次循环的都进行判断次数
4：循环剥离——将不通用的处理起来稍微费劲一些的动作，放在循环外处理