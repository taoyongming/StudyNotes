#### 并发容器

#### List

**CopyOnWriteArrayList**  适用于写操作非常少的场景



#### Map

ConcurrentHashMap  **key 是无序的**

ConcurrentSkipListMap **key 是有序的**

#### Set

CopyOnWriteArraySet 

ConcurrentSkipListSet

#### Queue

##### **单端阻塞队列**

ArrayBlockingQueue  有界

LinkedBlockingQueue 有界

SynchronousQueue

LinkedTransferQueue 

PriorityBlockingQueue  支持按照优先级出队

DelayQueue 支持延时出队

**双端阻塞队列**

LinkedBlockingDeque

**单端非阻塞队列**

 ConcurrentLinkedQueue

**双端非阻塞队列**

 ConcurrentLinkedDeque

#### 原子类：无锁工具类的典范

##### 原子化的基本数据类型

AtomicBoolean、AtomicInteger 和 AtomicLong

##### 原子化的对象引用类型

 AtomicReference

AtomicStampedReference 和 AtomicMarkableReference 这两个原子类可以解决 ABA 问题

##### 原子化数组

AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray

##### 原子化对象属性更新器

 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater

**对象属性必须是 volatile 类型的，只有这样才能保证可见性**

##### 原子化的累加器

DoubleAccumulator、DoubleAdder、LongAccumulator 和 LongAdder

#### 23 | Future：如何用多线程实现最优的“烧水泡茶”程序？

Java 通过 ThreadPoolExecutor 提供的 3 个 submit() 方法和 1 个 FutureTask 工具类来支持获得任务执行结果的需求。

```java
// 提交 Runnable 任务
Future<?> 
  submit(Runnable task);
// 提交 Callable 任务
<T> Future<T> 
  submit(Callable<T> task);
// 提交 Runnable 任务及结果引用  
<T> Future<T> 
  submit(Runnable task, T result);

```

它们的返回值都是 Future 接口，Future 接口有 5 个方法:

```java
// 取消任务
boolean cancel(
  boolean mayInterruptIfRunning);
// 判断任务是否已取消  
boolean isCancelled();
// 判断任务是否已结束
boolean isDone();
// 获得任务执行结果
get();
// 获得任务执行结果，支持超时
get(long timeout, TimeUnit unit);

```

调用 get() 方法的线程会阻塞，直到任务执行完才会被唤醒。

#### FutureTask 

```java
FutureTask(Callable<V> callable);
FutureTask(Runnable runnable, V result);

```

FutureTask 实现了 Runnable 和 Future 接口，FutureTask 对象可以很容易获取子线程的执行结果。

```java
// 创建 FutureTask
FutureTask<Integer> futureTask
  = new FutureTask<>(()-> 1+2);
// 创建线程池
ExecutorService es = 
  Executors.newCachedThreadPool();
// 提交 FutureTask 
es.submit(futureTask);
// 获取计算结果
Integer result = futureTask.get();

```

