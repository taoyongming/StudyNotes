#### 28 | Immutability模式：如何利用不变性解决并发问题？

将一个类及其所有的属性都设置成 final 的，并且只允许存在只读方法，那么这个类基本上就具备不可变性了。

如果需要提供类似修改的功能，创建一个新的不可变对象

享元模式（Flyweight Pattern）。利用享元模式可以减少创建对象的数量，从而减少内存占用。

享元模式本质上其实就是一个**对象池**，

#### 29 | Copy-on-Write模式

CopyOnWriteArrayList 和 CopyOnWriteArraySet 

除了 Java 这个领域，Copy-on-Write 在操作系统领域也有广泛的应用。

Copy-on-Write 最大的应用领域还是在函数式编程领域

#### 30 | 线程本地存储模式：没有共享，就没有伤害

Spring 使用 ThreadLocal 来传递事务信息。

ThreadLocal 的工作原理

```java
class Thread {
  // 内部持有 ThreadLocalMap
  ThreadLocal.ThreadLocalMap 
    threadLocals;
}
class ThreadLocal<T>{
  public T get() {
    // 首先获取线程持有的
    //ThreadLocalMap
    ThreadLocalMap map =
      Thread.currentThread()
        .threadLocals;
    // 在 ThreadLocalMap 中
    // 查找变量
    Entry e = 
      map.getEntry(this);
    return e.value;  
  }
  static class ThreadLocalMap{
    // 内部是数组而不是 Map
    Entry[] table;
    // 根据 ThreadLocal 查找 Entry
    Entry getEntry(ThreadLocal key){
      // 省略查找逻辑
    }
    //Entry 定义
    static class Entry extends
    WeakReference<ThreadLocal>{
      Object value;
    }
  }
}
```

**ThreadLocal 与内存泄露**

线程池使用ThreadLocal 会有内存泄漏。

解决方案，手动清理

```java
ExecutorService es;
ThreadLocal tl;
es.execute(()->{
  //ThreadLocal 增加变量
  tl.set(obj);
  try {
    // 省略业务逻辑代码
  }finally {
    // 手动清理 ThreadLocal 
    tl.remove();
  }
});
```

