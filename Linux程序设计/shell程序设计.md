#### 第一章 入门

| 项 目      | UNIX    | Windows     |
| ---------- | ------- | ----------- |
| 目标模块   | func.o  | FUNC.OBJ    |
| 静态函数库 | lib.a   | LIB.LIB     |
| 程序       | program | PROGRAM.EXE |

​		共享库在许多方面类似于Windows中使用的动态链接库。.so库对应于.DLL文件，它们都是在程序运行时加载，而.a库类似于.LIB文件，它们都包含在可执行程序中。

#### 第二章 Shell程序设计

**文件描述符**

 0 代表标准输入， 1 代表标准输出，2代表标准错误输出。

**shell的语法**

- 变量：字符串、数字、环境和参数
- 条件：shell中的布尔值
- 程序控制：if、elif、for、while、until、case
- 命令列表 
- 函数
  shell内置命令
- 获取命令的执行结果
- here文档

##### 变量

$HOME 当前用户的家目录

$PATH 以冒号分隔的用来搜索命令的目录列表

$0 shell脚本的名字

$# 传递给脚本的参数个数

$$ shell脚本的进程号，脚本程序通常会用它来生成一个唯一的临时文件，如/tmp/tmpfile_$$

##### 条件

**test或[命令**

​		注意，你必须在[符号和被检查的条件之间留出空格。要记住这一点，你可以把[符号看作和test命令一样，而test命令之后总是应该有一个空格。

​		test命令可以使用的条件类型可以归为3类：字符串比较、算术比较和与文件有关的条件测试。

文件条件测试结果
-d file 如果文件是一个目录则结果为真
-e file 如果文件存在则结果为真。要注意的是，历史上-e选项不可移植，所以通常使用的是-f选项
-f file 如果文件是一个普通文件则结果为真
-g file 如果文件的set-group-id位被设置则结果为真
-r file 如果文件可读则结果为真
-s file 如果文件的大小不为0则结果为真
-u file 如果文件的set-user-id位被设置则结果为真
-w file 如果文件可写则结果为真
-x file 如果文件可执行则结果为真



**控制结构**

if  , for , while ,until,case 

​		语句块{}  ： 如果你想在某些只允许使用单个语句的地方（比如在AND或OR列表中）使用多条语句，你可以
把它们括在花括号{}中来构造一个语句块。

**函数**

**命令**

**. 命令**

通常，当一个脚本执行一条外部命令或脚本程序时，它会创建一个新的环境（一个子shell），命令将在这个新环境中执行，在命令执行完毕后，这个环境被丢弃，留下退出码返回给父shell。但外部的source命令和点命令（这两个命令差不多是同义词）在执行脚本程序中列出的命令时，使用的是调用该脚本程序的同一个shell。

**echo 命令**

​		输出结尾带有换行符的字符串。

**eval 命令**

​		eval命令允许你对参数进行求值。它是shell的内置命令，通常不会以单独命令的形式存在。

**exec 命令**

​		将当前shell替换为一个不同的程序

**exit n 命令**

​		exit命令使脚本程序以退出码n结束运行。

**export命令**

​		一旦一个变量被shell导出，它就可以被该shell调用的任何脚本使用，也可以被后续依次调用的任何shell使用。

**expr命令**

​		expr命令将它的参数当作一个表达式来求值。x='expr $x +1'

​		在较新的脚本程序中，expr命令通常被替换为更有效的$((...))语法。

**printf命令**

**return命令**

**set命令**

​		set命令的作用是为shell设置参数变量。许多命令的输出结果是以空格分隔的值，如果需要使用输出结果中的某个域，这个命令就非常有用。

**shift命令**

​		shift命令把所有参数变量左移一个位置。

**trap命令**

​		trap命令有两个参数，第一个参数是接收到指定信号时将要采取的行动，第二个参数是要处理的信号名。

```shell
 trap 'rm -f /tmp/my_tmp_file_$$' INT
```

**unset命令**

​		unset命令的作用是从环境中删除变量或函数。这个命令不能删除shell本身定义的只读变量（如IFS）。

**find命令**

```shell
find / -name tests -print
```

使用带测试的find命令

在当前目录下搜索比文件while2要新的文件：

```shell
find . -newer while2  - type f -print
```

**-exec**和**-ok**命令将命令行上后续的参数作为它们参数的一部分，直到被 \; 序列终止。实际上，-exec和-ok命令执行的是一个嵌入式命令，所以嵌入式命令必须以一个转义的分号结束，使得find命令可以决定什么时候它可以继续查找用于它自己的命令行选项。魔术字符串**{}**是-exec或-ok命令的一个特殊类型的参数，它将被当前文件的完整路径代。

```shell
find . -newer  while2 -type f  -exec ls -l {} \;
```

**grep命令**

```shell
grep in words.txt
grep -c in words.txt words2.txt
grep -c -v in words.txt words2.txt
```

**正则表达式**

| 字符 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| ^    | 指向一行的开头                                               |
| $    | 指向一行的结尾                                               |
| .    | 任意单个字符                                                 |
| []   | 方括号内包含一个字符范围，其中任何一个字符都可以被匹配，例如字符范围a～e，或在字符范围前面加上^符号表示使用反向字符范围，即不匹配指定范围内的字符 |

| 选项  | 含义                         |
| ----- | ---------------------------- |
| ?     | 匹配是可选的，但最多匹配一次 |
| *     | 必须匹配0次或多次            |
| +     | 必须匹配1次或多次            |
| {n}   | 必须匹配n次                  |
| {n,}  | 必须匹配n次或n次以上         |
| {n,m} | 匹配次数在n到m之间，包括n和m |

(1)我们的第一个例子是查找以字母e结尾的行。

```shell
grep e$ words2.txt
```

(2) 现在假设想要查找以字母a结尾的单词。要完成这一任务，你需要使用方括号括起的特殊匹配字符。在本例中，你将使用的是[[:blank:]]，它用来测试空格或制表符：

```shell
 grep a[[:blank:]] words2.txt 
```

(3)下面我们来查找以Th开头的由3个字母组成的单词。在本例中，你既需要使用[[:space:]]来
划定单词的结尾，还需要用字符（.）来匹配一个额外的字符：

```shell
grep Th.[[:space:]] words2.txt
```

(4) 最后，我们用扩展grep模式来搜索只有10个字符长的全部由小写字母组成的单词。我们通过
指定一个匹配字母a到z的字符范围和一个重复10次的匹配来完成这一任务：

```shell
grep -E [a-z]{10} words2.txt
```

**命令的执行**

编写脚本程序时，你经常需要捕获一条命令的执行结果，并把它用在shell脚本程序中。也就是说，你想要执行一条命令，并把该命令的输出放到一个变量中。

```shell
echo The current directory is $PWD
echo The current users are $(who)
whoisthere=$(who)
echo $whoisthere

exit 0
```

1. 算术扩展

我们已经介绍过expr命令，通过它可以处理一些简单的算术命令，但这个命令执行起来相当慢，
因为它需要调用一个新的shell来处理expr命令。
一种更新更好的办法是使用$((...))扩展。把你准备求值的表达式括在$((...))中能够更有效
地完成简单的算术运算。如下所示：

```shell
#!/bin/sh

x=0
while [ "$x" -ne 10 ]; do
    echo $x
    x=$(($x+1))
done

exit 0
```

2. 参数扩展

你已经见过形式最简单的参数赋值和扩展了

```shell
foo=fred
echo $foo
```

当你想在变量名后附加额外的字符，需要写成

```shell
for i in 1 2 
do 
	my_secret_process ${i}_tmp
done
```

here 文档

在shell脚本程序中向一条命令传递输入的一种特殊方法是使用here文档。它允许一条命令在获得输入数据时就好像是在读取一个文件或键盘一样，而实际上是从脚本程序中得到输入数据。
here文档以两个连续的小于号<<开始，紧跟着一个特殊的字符序列，该序列将在文档的结尾处再次出现。<<是shell的标签重定向符，

是给cat命令提供输入数据

```shell
#!/bin/sh
cat <<!funky!
hello
this is a here
docunment
!funky!

```

