##### 15 | 理论一：对于单一职责原则（Single Responsibility Principle），如何判定某个类的职责是否够“单一”？

1. 如何理解单一职责原则（SRP）？

   A class or module should have a single reponsibility。

   一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。

##### 16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？

开闭原则的英文全称是 Open Closed Principle，简写为 OCP。它的英文描述是：

software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。

我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。

在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：

- 多态
- 依赖注入
- 基于接口而非实现编程
- 以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。

##### 17 | 理论三：里式替换 Liskov Substitution Principle（LSP）跟多态有何区别？哪些代码违背了LSP？

Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。

子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

**多态和LSP的区别：**

多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。

而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。

##### 18 | 理论四：接口隔离原则（Interface Segregation Principle）有哪三种应用？原则中的“接口”该如何理解？

Clients should not be forced to depend upon interfaces that they do not use.

客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。

##### 19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？

控制反转（IOC）

**框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。**

这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。

实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有马上要讲到的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。

依赖注入（DI）

我们用一句话来概括就是：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。

依赖反转原则（DIP）

High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.

高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。

Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Sevlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。

##### 20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？

对于如何写出满足 KISS 原则的代码，我还总结了下面几条指导原则：

- 不要使用同事可能不懂的技术来实现代码；
- 不要重复造轮子，要善于使用已经有的工具类库；
- 不要过度优化。

##### 21 | 理论七：重复的代码就一定违背DRY（Don’t Repeat Yourself）吗？如何提高代码的复用性？

代码复用性,提高代码可复用性的一些方法，有以下 7 点。

- 减少代码耦合
- 满足单一职责原则
- 模块化
- 业务与非业务逻辑分离
- 通用代码下沉
- 继承、多态、抽象、封装
- 应用模板等设计模式

在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性。

我们可以不写可复用的代码，但一定不能写重复的代码。

#####  实战一：针对业务系统的开发，如何做需求分析和设计？

面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。实际上，我们可以借鉴面向对象设计的步骤，来做系统设计。

面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。

在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互了。

##### 实战二：针对非业务的通用框架开发，如何做需求分析和设计？

对于非业务通用框架的开发，我们在做需求分析的时候，除了功能性需求分析之外，还需要考虑框架的非功能性需求。比如，框架的易用性、性能、扩展性、容错性、通用性等。

对于复杂框架的设计，很多人往往觉得无从下手。今天我们分享了几个小技巧，其中包括：画产品线框图、聚焦简单应用场景、设计实现最小原型、画系统设计图等。这些方法的目的都是为了让问题简化、具体、明确，提供一个迭代设计开发的基础，逐步推进。

